  *created "Wed Feb 16 08:52:17 2022" *by "Paul E. Black"
 *modified "Fri Nov  4 13:36:09 2022" *by "Paul E. Black"
 
Ideas for Enhancement of and Things To Do for VTSG

FIX BUGS - HANDLE ALL CURRENT LANGUAGES

Eliminate initial superfluous newline at the beginning of file.

6 Sep 2022
Fix Python "Classes" complexity:
The main file must import the class-defining file, e.g.
from CWE_78__I_hardcoded_string_input__F_none__S_ls__1_22b import Class_884

2 Nov 2022
Reset the "variable name" counter for each test case.  That is, generate the same
variable, function, etc. names for each case regardless of what was (or was not)
generated before it.  For instance,
    i_890 = 1
    for x in range(0, i_890):
If more or fewer cases were generated before this one, the name i_890 will differ.

4 Nov 2022
Make the names of language files consistent.  The files with input and sink modules
are input.xml and sink.xml.  The file with filter modules is filtering.xml (a
gerund).  The file with complexity and condition modules is complexities.xml
(plural).  The file with execution query modules is exec_queries.xml (short name and
plural).
    File names are in file_manager.py.  The file names are in the template directories.


Make sure the PHP and C# code runs, that is, that the generated programs are valid.
Fix any problems . . .

C#
  - check all str functions
  - Complexities :
      - if        : Testing
      - ternary   : None (possible?)
      - switch    : Testing
      - goto      : Testing
      - loop      : Testing
          - for       : Testing
          - while     : Testing
          - foreach   : Testing
      - function  : Testing (only trasversal/in/out)
      - classes   : Testing (only trasversal/in/out)
  # Not important
  - benchmark functions
  - use cython or JVM for optimization ?
  # Hard to do
  - add C# print debug to test if safe/unsafe or if it's executed
  - create bash script to compile and run all C# code
      -> compilation script done

Isolate code related to complexities.  Complexities relating to classes are
functional, however, the code needs to be isolated so it does not interfere with
other languages.  Python includes classes from other files using the “from {file}
import {class}” syntax, whereas other languages might not. This poses an issue when
generating other languages.  Example:
    cwe_78__I_hardcoded_string_input__F_no_filtering__S_ls__1x20b import Class_880
    This import for the file containing the class may not look anything like this in
    another language

Maybe add language-specific code in VTSG itself instead of trying to specify the
syntax (and composition rules) in, say, file_template.xml.  For example, C++ and C#
are far more similar in syntax than C# and Python.  This will help lessen the amount
of code that the generator runs specifically running only the functions it needs for
each language.


GENERATE MORE KINDS OF CASES

Extend VTSG & Python to handle (all?) Juliet-type cases
    (1) Now VTSG is structured to create injection cases. I don't know how well it
       could produce integer overflow, divide by zero, etc. type cases.
    (2) Juliet cases have lots of *type* variation: do the same thing, but with
       char, int, float, array, etc. Can we get VTSG to do that? Easily?
    This is probably a LOT of work since there are so many different kinds of test
    cases and complexities in Juliet.

Add swapped argument errors, see Vineeth Kashyap https://arxiv.org/abs/2009.09117

Add complexities from Kratkiewcz test cases

Generalize the structure of VTSG.  Now it looks for inputs, filters, and queries in
rigid combinations.  Maybe VTSG should read the template, then go hunting for each
kind of module mentioned.  Connections between them, via variables or call/return,
could be generalized.
    I don't know if this is even needed.  We first must work on handling Juliet and
other cases to discover any limitations VTSG has.


GENERATE CASES SMARTER

Don't "declare" local variables if not necessary, e.g., in Python.

Create s01, s02, s03, etc. subdirectories so there aren't hundreds of thousands of
cases in one directory.

Enhance VTSG to produce p% of cases.  That is, it would write 1 of every N
combinations, including complexities, that it comes up with.  This is an easy way to
approximate combinatorial tests.
    An alternative is to (pseudo)randomly decide which case to write.  That is, write
any case with probability p%.  This should write about p% of cases.  It must be
PSEDUOrandom so we can provide a seed and generate exactly the same cases in each
test run.
    The -n (number generated) option does something vaguely like this.  However, it
stops generation after N sink/filter/input/exec query combinations are generated.
Search for number_generated in generator.py.

Enhance VTSG to count and report (not print) cases.
    This is a prelude to combinatorial test generation, see next.

Incorporate combinatorial test generation
    Now VTSG generates all combinations, like Juliet. It may be useful to generate
    all n-way combinations.  This allows *far* more situations to be generated
    without making millions of cases.


OTHER? GENERAL?

Shorten the generated file name.  Or, add a --short-case-name option, to produce
Juliet-like names.
    A better alternative is to allow the user to specify generated file name in a
general format, like strftime, ISO/IEC 9899 (C90), or find -printf.  Here is a sample:
  %A is the full weekday name.
  %a is the abbreviated weekday name.
  %B is the full month name.
  %b is the abbreviated month name.
  %d is the day of the month as a decimal number (01-31).
  %H is the hour (24-hour clock) as a decimal number (00-23).
  %I is the hour (12-hour clock) as a decimal number (01-12).
  %M is the minute as a decimal number (00-59).
  %m is the month as a decimal number (01-12).

The built-in-test rules in the Makefile leave a lot of "junk" files and directories
in the current directory.  Put all the self-test stuff in another directory so the
top-level directory doesn't get cluttered.

Write manifest in our current SARIF-style.  There is sarif_writer.py, which is a
start from August 2020.  A newer implementation (Dec 2021) of sarif writer is in Paul's
Work/Ockham.

Update contact and license information in setup.py.  (Re)register in PyPI. Let
Bertrand know about this new GitHub repository, so he can "point" his to this one.

end of TODO
