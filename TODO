  *created "Wed Feb 16 08:52:17 2022" *by "Paul E. Black"
 *modified "Wed Feb 23 13:31:20 2022" *by "Paul E. Black"
 
Ideas for Enhancement of and Things To Do for VTSG

FIX BUGS - HANDLE ALL CURRENT LANGUAGES

16 Feb 2022
Correct Fig. 9 (final code example) in manual.  It does not have a //flaw line.
Since the example sink.xml has //flaw, it should.
  Related: create a language especially for the example in the manual so we can rerun
when VTSG changes.

Get indentation working ("deterministically"), for Python

Make sure the PHP and C# code runs, that is, that the generated programs are valid.
Fix any problems . . .

Isolate code related to complexities.  Complexities relating to classes are
functional, however, the code needs to be isolated so it does not interfere with
other languages.  Python includes classes from other files using the “from {file}
import {class}” syntax, whereas other languages might not. This poses an issue when
generating other languages.  Example:
    cwe_78__I_hardcoded_string_input__F_no_filtering__S_ls__1x20_File2 import Class_880
    This import for the file containing the class may not look anything like this in
    another language

Maybe add language-specific code in VTSG itself instead of trying to specify the
syntax (and composition rules) in, say, file_template.xml.  For example, C++ and C#
are far more similar in syntax than C# and Python.  This will help lessen the amount
of code that the generator runs specifically running only the functions it needs for
each language.


GENERATE MORE TYPES OF CASES

Extend VTSG & Python to handle (all?) Juliet-type cases
    (1) Now VTSG is structured to create injection cases. I don't know how well it
       could produce integer overflow, divide by zero, etc. type cases.
    (2) Juliet cases have lots of *type* variation: do the same thing, but with
       char, int, float, array, etc. Can we get VTSG to do that? Easily?
    This is probably a LOT of work since there are so many different kinds of test
    cases and complexities in Juliet.

Add swapped argument errors, see Vineeth Kashyap https://arxiv.org/abs/2009.09117

Add complexities from Kratkiewcz test cases

Generalize the structure of VTSG.  Now it looks for inputs, filters, and queries in
rigid combinations.  Maybe VTSG should read the template, then go hunting for each
kind of module mentioned.  Connections between them, via variables or call/return,
could be generalized.
    I don't know if this is even needed.  We first must work on handling Juliet and
other cases to discover any limitations VTSG has.


GENERATE CASES SMARTER

Don't "declare" local variables if not necessary, e.g., in Python.

Shorten the generated file name.  For instance, Juliet uses suffixes a, b, c,
etc. when a test case includes multiple files.  VTSG adds _File1 to all files.

Create s01, s02, s03, etc. subdirectories so there aren't hundreds of thousands of
cases in one directory.

Enhance VTSG to count and report (not print) cases.
    This is a prelude to combinatorial test generation, below

Enhance VTSG to produce p% of cases.  That is, it would write 1 of every N
combinations that it comes up with.  This is an easy way to approximate
combinatorial tests.
    An alternative is to (pseudo)randomly decide which case to write.  That is, write
any case with probability p%.  This should write about p% of cases.  It must be
PSEDUOrandom so we can provide a seed and generate exaclty the same cases in each
test run.

Incorporate combinatorial test generation
    Now VTSG generates all combinations, like Juliet. It may be useful to generate
    all n-way combinations.  This allows *far* more situations to be generated
    without making millions of cases.


OTHER? GENERAL?

Add a --programming-language-directory command line option.  (Choose a more succinct
name.)  When given, VTSG looks in that directory for the "language" instead of in
src/templates.  We (will) have LOTS of test "languages". It would be less confusing if
they could be somewhere else and only have "production" languages under
src/templates.

Write manifest in our current SARIF-style.  There is sarif_writer.py, which is a
start from August 2020.  A newer implemention (Dec 2021) is in Paul's Work/Ockham.

end of TODO
