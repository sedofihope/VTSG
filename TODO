*created "Wed Feb 16 08:52:17 2022" *by "Paul E. Black"
 *modified "Thu May 18 11:17:38 2023" *by "Paul E. Black"
 
Ideas for Enhancement of and Things To Do for VTSG

FIX BUGS - HANDLE ALL CURRENT LANGUAGES

30 March 2023

Add some kind of --label or --source option so that every line of code in the final
generated case has some comment indicating where it comes from.  Something like
    try:                                     # input
        tainted_0 = int(sys.argv[1])         # input
    except ValueError:                       # input
        tainted_0 = 1776                     # input
                                             # input
    tainted_1 = tainted_0                    # synthesized
                                             # filter
    # No filtering (sanitization)            # filter
    tainted_1 = tainted_0                    # filter
                                             # filter
    array = [0, 1, 2, 3, 4]                  # sink
(The file name tells us *which* input, filter, or sink was used.)


21 March 2023

Have some method of variants. They are vaguely like complexities, but apply broadly.
Juliet has the same code instantiated with different types.  Kratkiewcz has array
access at the end, just beyond, some beyond, and far beyond.  These variants have to
potentially be incorporated in all modules.  Kratkiewcz also has a few basic loop
templates, but then does variants on them where the initial value, the terminating
test value, or the increment value (and combinations of all of them!) are passed
through variables instead of being hardcoded.

Sinks should be able to supply code to other modules.  In particular, certain sinks
need a hardcoded "input" to be a certain value in order to be safe or to exploit the
weakness.


21 March 2023

Warn if the chosen sink doesn't generate any test cases.  It's relatively easy to
warn if there are no matching filters.  It gets progressively harder to count that
there are no filter/input or filter/input/exec_query combinations.
    Maybe just count the number of cases generated (for an input).  If the number is
zero, produce a warning.


4 Jan 2023

Change <dir> in modules to <des> (for description) or something.  This is only used
in test case names.  Maybe files were originally placed in separate directories
depending on their input or sink.  Thus <path> ... <dir> made sense.  (This may be
why multiple <dir> entries are allowed.)

Maybe replace the <path> <dir> stuff with one <description> or <name> keyword.
(You'd have to fix a few modules with multiple <dir> entries.)


3 Mar 2023

Allow the user to specify the variable name root, that is, something other than
"tainted".


4 Jan 2023

Maybe there should be a new value "maybe" or "random" or "indeterminate" for test
conditions code when the analyzer cannot determine.  For instance, Juliet,
    if (random()) {
        code
    }



23 Nov 2022
Thoroughly document what various attributes in complexities do. For instance,
• indirection: “1” if the code is split into two chunks (call and declaration) or
  calls a function. The body tag should be present when calling a function.
What does indirection="1" DO to the final code?? Does indirection="0" do anything,
that is, is this an optional flag?  Other attributes that need more explanation are
• need_id
• in_out_var (especially the magic that happens when the value is "traversal")


6 Sep 2022
Fix Python "Classes" complexity:
The main file must import the class-defining file, e.g.
from CWE_78__I_hardcoded_string_input__F_none__S_ls__1_22b import Class_884

Also, in complexities_generator.py about line 241, union imports and call
generate_imports(), like the code in generator.py at # IMPORTS.
"using {{import}};" is currently hardcoded.


16 Nov 2022
Explain in manual what "supported" complexity types and groups do.  That is, *any*
string can be placed in type or group, but some strings trigger special functions in
VTSG.

Add examples of how to code things or how to use options, like need_id.


7 Nov 2022
Complexities are only wrapped around filters.  In Juliet they can wrap the sink (and
the input, I think).  Maybe add markers in file_template.xml to indicate where
complexities can go?  VTSG's current scheme would be represented as:
    {{begin_complexity}}
    INDENT
        {{filtering_content}}
    DEDENT
    {{end_complexity}}
    {{sink_content}}
Here's Juliet's scheme:
    {{filtering_content}}
    {{begin_complexity}}
    INDENT
        {{sink_content}}
    DEDENT
    {{end_complexity}}


7 Nov 2022
An unrecognized input module input_type, that is, one that doesn't appear in the
file_template, results in variables with no initialization:
    tainted_0 =
    tainted_1 =
There should be a check or warning about this.
Note: get_init_var_code() in file_template.py return empty string if type is not
found.  The only place it is called, complexities_generator.py line 283, checks for
invalid return, but it checks for (not) None.
    Different or custom types make it easier to connect certain flaw templates with
the proper initialization or input.

A higher level capability is to allow "qualified" types, e.g.
    <input_type>int,primesOnly</input_type>
so flaws that need a particular "input" to be "hooked" to modules that produce that
particular output.

9 Nov 2022
Any module should be able to add imports or global declarations.  Specifically,
conditions or complexities may exercise certain libraries or packages or may need a
global variable declared.
    This allows file_template to be smaller.  The final code only includes say, math,
when it is needed.

Allow modules, other than complexities, to have <body></body> code to be placed in
another file.


9 Nov 2022
VTSG doesn't have any notion of a fixed "support" file.  That is, a file written by
the developer that the test cases (may) need in order to execute.  This is like
testcasesupport files, for instance, io.c or std_testcase.h.
    This support file would have to be copied into any directory where test cases are
placed. 

7 Nov 2022
There should be some way to put several pieces of generated code in the same case, to
mimic Juliet's structure of having a bad version and one or more good versions in the
same file.

Note: that we can mimic Juliet's corresponding good and bad cases by having TWO
sinks: one with the good code and one with the bad code.  They go in separate test
cases (in different subdirectories: safe and unsafe), but at least it's a way for
VTSG to generate matched pairs (or triples if we need two good versions).  Idea: the
sinks could have comments that connect the two cases, e.g., "This case has a
corresponding bad [good] case with the same name, but OBOb [OBOg] as the sink."


23 Nov 2022
Enhance the Juliet/Python tests with THREE variable scopes if you want to make sure
analyzers follow Python scope rules.
    Change localFive and globalFive to localConst and globalConst, and add an
enclosingConst.  These can be combinations of 5 or not 5.  Refer to scopeConst, e.g.
    def f():
        scopeConst = 6

	def g():
	    scopeConst = 5

	    if scopeConst == 5:
	        # this will always execute . . .
or perhaps
	scopeConst = globalConst

7 Nov 2022
Adding a // flaw line is only done for sink modules.  (In generator.py, around line
430; search for # add comment into code ...)  To be more general, perhaps VTSG should
be capable of adding a //flaw line in any module.

10 Nov 2022
Add a "new case hook". That is, every time a new case is written, VTSG will run
a script(?) you give as a "hook".  This takes advantage of modern
multiprocessors.  While VTSG is generating cases, the generated cases can be
checked or executed.

4 Nov 2022
Make the names of language modules consistent.  In particular, filter modules and
functions are often referred to as "filtering".
   Change language entries from {{ filtering_content }} to {{ filter_content }}?


Make sure the PHP and C# code runs, that is, that the generated programs are valid.
Fix any problems . . .

C#
  - check all str functions
  - Complexities :
      - if        : Testing
      - ternary   : None (possible?)
      - switch    : Testing
      - goto      : Testing
      - loop      : Testing
          - for       : Testing
          - while     : Testing
          - foreach   : Testing
      - function  : Testing (only traversal/in/out)
      - classes   : Testing (only traversal/in/out)
  # Hard to do
  - add C# print debug to test if safe/unsafe or if it's executed
  - create bash script to compile and run all C# code
      -> compilation script done

Isolate code related to complexities.  Complexities relating to classes are
functional, however, the code needs to be isolated so it does not interfere with
other languages.  Python includes classes from other files using the “from {file}
import {class}” syntax, whereas other languages might not. This poses an issue when
generating other languages.  Example:
    cwe_78__I_hardcoded_string_input__F_no_filtering__S_ls__1x20b import Class_880
    This import for the file containing the class may not look anything like this in
    another language

Maybe add language-specific code in VTSG itself instead of trying to specify the
syntax (and composition rules) in, say, file_template.xml.  For example, C++ and C#
are far more similar in syntax than C# and Python.  This will help lessen the amount
of code that the generator runs specifically running only the functions it needs for
each language.


GENERATE MORE KINDS OF CASES

Extend VTSG & Python to handle (all?) Juliet-type cases
    (1) Now VTSG is structured to create injection cases. I don't know how well it
       could produce integer overflow, divide by zero, etc. type cases.
    (2) Juliet cases have lots of *type* variation: do the same thing, but with
       char, int, float, array, etc. Can we get VTSG to do that? Easily?
    This is probably a LOT of work since there are so many different kinds of test
    cases and complexities in Juliet.

Add swapped argument errors, see Vineeth Kashyap https://arxiv.org/abs/2009.09117

Generalize the structure of VTSG.  Now it looks for inputs, filters, and queries in
rigid combinations.  Maybe VTSG should read the template, then go hunting for each
kind of module mentioned.  Connections between them, via variables or call/return,
could be generalized.
    I don't know if this is even needed.  We first must work on handling Juliet and
other cases to discover any limitations VTSG has.


GENERATE CASES SMARTER

Create s01, s02, s03, etc. subdirectories so there aren't hundreds of thousands of
cases in one directory.

Enhance VTSG to produce p% of cases.  That is, it would write 1 of every N
combinations, including complexities, that it comes up with.  This is an easy way to
approximate combinatorial tests.
    An alternative is to (pseudo)randomly decide which case to write.  That is, write
any case with probability p%.  This should write about p% of cases.  It must be
PSEDUOrandom so we can provide a seed and generate exactly the same cases in each
test run.
    The -n (number generated) option does something vaguely like this.  However, it
stops generation after N sink/filter/input/exec query combinations are generated.
Search for number_generated in generator.py.

Incorporate combinatorial test generation
    Now VTSG generates all combinations, like Juliet. It may be useful to generate
    all n-way combinations.  This allows *far* more situations to be generated
    without making millions of cases.


OTHER? GENERAL?

Shorten the generated file name.  Or, add a --short-case-name option, to produce
Juliet-like names.
    A better alternative is to allow the user to specify generated file name in a
general format, like strftime, ISO/IEC 9899 (C90), or find -printf.  Here is a sample:
  %A is the full weekday name.
  %a is the abbreviated weekday name.
  %B is the full month name.
  %b is the abbreviated month name.
  %d is the day of the month as a decimal number (01-31).
  %H is the hour (24-hour clock) as a decimal number (00-23).
  %I is the hour (12-hour clock) as a decimal number (01-12).
  %M is the minute as a decimal number (00-59).
  %m is the month as a decimal number (01-12).

The built-in-test rules in the Makefile leave a lot of "junk" files and directories
in the current directory.  Put all the self-test stuff in another directory so the
top-level directory doesn't get cluttered.

Write manifest in our current SARIF-style.  There is sarif_writer.py, which is a
start from August 2020.  A newer implementation (Dec 2021) of sarif writer is in Paul's
Work/Ockham.

Update contact and license information in setup.py.  (Re)register in PyPI. Let
Bertrand know about this new GitHub repository, so he can "point" his to this one.

end of TODO
