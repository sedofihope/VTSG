  *created "Wed Feb 16 08:52:17 2022" *by "Paul E. Black"
 *modified "Tue Sep 13 11:01:12 2022" *by "Paul E. Black"
 
Ideas for Enhancement of and Things To Do for VTSG

FIX BUGS - HANDLE ALL CURRENT LANGUAGES

16 Feb 2022
Correct Fig. 9 (final code example) in the manual.  It does not have a //flaw line.
Since the example sink.xml has //flaw, it should.
  Related: create a "language" especially for the example in the manual so we can rerun 
when VTSG changes.

Eliminate initial superfluous newline at the beginning of file.

6 Sep 2022
Fix Python "Classes" complexity:
The main file must import the class-defining file, e.g.
from CWE_78__I_hardcoded_string_input__F_none__S_ls__1_22_File2 import Class_884

Make sure the PHP and C# code runs, that is, that the generated programs are valid.
Fix any problems . . .

C#
  - check all str functions
  - Complexities :
      - if        : Testing
      - ternary   : None (possible?)
      - switch    : Testing
      - goto      : Testing
      - loop      : Testing
          - for       : Testing
          - while     : Testing
          - foreach   : Testing
      - function  : Testing (only trasversal/in/out)
      - classes   : Testing (only trasversal/in/out)
  # Not important
  - benchmark functions
  - use cython or JVM for optimization ?
  # Hard to do
  - add C# print debug to test if safe/unsafe or if it's executed
  - create bash script to compile and run all C# code
      -> compilation script done

Isolate code related to complexities.  Complexities relating to classes are
functional, however, the code needs to be isolated so it does not interfere with
other languages.  Python includes classes from other files using the “from {file}
import {class}” syntax, whereas other languages might not. This poses an issue when
generating other languages.  Example:
    cwe_78__I_hardcoded_string_input__F_no_filtering__S_ls__1x20_File2 import Class_880
    This import for the file containing the class may not look anything like this in
    another language

Maybe add language-specific code in VTSG itself instead of trying to specify the
syntax (and composition rules) in, say, file_template.xml.  For example, C++ and C#
are far more similar in syntax than C# and Python.  This will help lessen the amount
of code that the generator runs specifically running only the functions it needs for
each language.

Document ability in vtsg.py to run astyle (indentation tool) if it exists.


GENERATE MORE KINDS OF CASES

Extend VTSG & Python to handle (all?) Juliet-type cases
    (1) Now VTSG is structured to create injection cases. I don't know how well it
       could produce integer overflow, divide by zero, etc. type cases.
    (2) Juliet cases have lots of *type* variation: do the same thing, but with
       char, int, float, array, etc. Can we get VTSG to do that? Easily?
    This is probably a LOT of work since there are so many different kinds of test
    cases and complexities in Juliet.

Add swapped argument errors, see Vineeth Kashyap https://arxiv.org/abs/2009.09117

Add complexities from Kratkiewcz test cases

Generalize the structure of VTSG.  Now it looks for inputs, filters, and queries in
rigid combinations.  Maybe VTSG should read the template, then go hunting for each
kind of module mentioned.  Connections between them, via variables or call/return,
could be generalized.
    I don't know if this is even needed.  We first must work on handling Juliet and
other cases to discover any limitations VTSG has.


GENERATE CASES SMARTER

Don't "declare" local variables if not necessary, e.g., in Python.

Create s01, s02, s03, etc. subdirectories so there aren't hundreds of thousands of
cases in one directory.

Enhance VTSG to produce p% of cases.  That is, it would write 1 of every N
combinations, including complexities, that it comes up with.  This is an easy way to
approximate combinatorial tests.
    An alternative is to (pseudo)randomly decide which case to write.  That is, write
any case with probability p%.  This should write about p% of cases.  It must be
PSEDUOrandom so we can provide a seed and generate exactly the same cases in each
test run.
    The -g (number generated) option does something vaguely like this.  However, it
stops generation after N sink/filter/input/exec query combinations are generated.
Search for number_generated in generator.py.

Enhance VTSG to count and report (not print) cases.
    This is a prelude to combinatorial test generation, see next.

Incorporate combinatorial test generation
    Now VTSG generates all combinations, like Juliet. It may be useful to generate
    all n-way combinations.  This allows *far* more situations to be generated
    without making millions of cases.


OTHER? GENERAL?

Shorten the generated file name.  For instance, Juliet uses suffixes a, b, c,
etc. when a test case includes multiple files.  VTSG adds _File1 to all files.
    Or, add a --short-case-name option, to produce Juliet-like names.
    A better alternative is to allow the user to specify generated file name in a
general format, like strftime or ISO/IEC 9899 (C90).  Here is a sample:
  %A is the full weekday name.
  %a is the abbreviated weekday name.
  %B is the full month name.
  %b is the abbreviated month name.
  %d is the day of the month as a decimal number (01-31).
  %H is the hour (24-hour clock) as a decimal number (00-23).
  %I is the hour (12-hour clock) as a decimal number (01-12).
  %M is the minute as a decimal number (00-59).
  %m is the month as a decimal number (01-12).

Add a --programming-language-directory command line option.  (Choose a more succinct
name.)  When given, VTSG looks in that directory for the "language" instead of in
src/templates.  We (will) have LOTS of test "languages". It would be less confusing if
they could be somewhere else and only have "production" languages under
src/templates.

The built-in-test rules in the Makefile leave a lot of "junk" files and directories
in the current directory.  Put all the self-test stuff in another directory so the
top-level directory doesn't get cluttered.

Write manifest in our current SARIF-style.  There is sarif_writer.py, which is a
start from August 2020.  A newer implementation (Dec 2021) of sarif writer is in Paul's
Work/Ockham.

Change --cwe option to be something like --flaw_type.  Now that these can be, say,
BF or SEI CERT Secure Coding Standards
https://wiki.sei.cmu.edu/confluence/display/seccode/
the option should be more generic.

Update contact and license information in setup.py.  (Re)register in PyPI. Let
Bertrand know about this new GitHub repository, so he can "point" his to this one.

end of TODO
