*created "Wed Feb 16 08:52:17 2022" *by "Paul E. Black"
 *modified "Wed Nov 23 11:35:22 2022" *by "Paul E. Black"
 
Ideas for Enhancement of and Things To Do for VTSG

FIX BUGS - HANDLE ALL CURRENT LANGUAGES

Eliminate initial superfluous newline at the beginning of file.

23 Nov 2022
Thoroughly document what various attributes in complexities do. For instance,
• indirection: “1” if the code is split into two chunks (call and declaration) or
  calls a function. The body tag should be present when calling a function.
What does indirection="1" DO to the final code?? Does indirection="0" do anything,
that is, is this an optional flag?  Other attributes that need more explanation are
• need_id
• in_out_var (especially the magic that happens when the value is "traversal")

6 Sep 2022
Fix Python "Classes" complexity:
The main file must import the class-defining file, e.g.
from CWE_78__I_hardcoded_string_input__F_none__S_ls__1_22b import Class_884

16 Nov 2022
Explain in manual what "supported" complexity types and groups do.  That is, *any*
string can be placed in type or group, but some strings trigger special functions in
VTSG.

Add examples of how to code things or how to use options, like need_id.

Maybe add a diagram showing how output_type of one module "hooks" to the input_type
of the next module?

18 Nov 2022
Separate generation of cases from the cases being generated.  That is, have a
class for the case being generated different from the generator.  Many generator
class flags and data are not needed for the case:
    date  Human readable date of the generation.
    _max_recursion Max level of recursion with complexities
    _number_generated Number of triplets (input,filter,sink) to generate
    dir_name  Directory name of the folder containing generated cases.
    manifest object to complete the manifest file with references to generated files.
    safe_sample Counter for safe sample.
    unsafe_sample Counter for unsafe sample.
    report (dict): The report for each group of flaws.
    flaw_type_user Flaw types entered by user for the generation.
    flaw_group_user Flaw groups entered by user for the generation.
    start (float): Starting time of the generation.
    end (float): Ending generate time.
    tab_input all input modules.
    tab_filtering all filter modules.
    tab_sink all sink modules.
    tab_exec_queries all exec query modules.
    tab_complexity all complexity possibilities.
    tab_condition all condition possibilities.
    ?file_template FileTemplate the template for current langage.
    map_flaw_group dict associating flaws with flaw groups

Here is the beginning of code for this

class Test_Case:
    """This is a single test case.  The various modules are composed to make all the
    source code for a complete test case.  The source code is eventually written to
    disk and logged for the report and manifest."""

    def __init__(self, input_module, filter_module, complexities, sink_module,
                 exec_query_module):
        self.input_module      = input_module
        self.filter_module     = filter_module
        self.complexities      = complexities
        self.sink_module       = sink_module
        self.exec_query_module = exec_query_module

Add in generator.py about line 98:
        test_cases = []

Add in generator.py about line 376:
        # Save this combination
        new_case = Test_Case(self.current_input, self.current_filter,
                             self.current_sink,  self.current_exec_queries,
                             self.complexities_queue)
        self.test_cases.append(new_case)



7 Nov 2022
Complexities are only wrapped around filters.  In Juliet they can wrap the sink (and
the input, I think).  Maybe add markers in file_template.xml to indicate where
complexities can go?  VTSG's current scheme would be represented as:
    {{begin_complexity}}
    INDENT
        {{filtering_content}}
    DEDENT
    {{end_complexity}}
    {{sink_content}}
Here's Juliet's scheme:
    {{filtering_content}}
    {{begin_complexity}}
    INDENT
        {{sink_content}}
    DEDENT
    {{end_complexity}}

7 Nov 2022
An unrecognized input module input_type, that is, one that doesn't appear in the
file_template, results in variables with no initialization:
    tainted_0 =
    tainted_1 =
There should be a check or warning about this.
Note: get_init_var_code() in file_template.py return empty string if type is not
found.  The only place it is called, complexities_generator.py line 283, checks for
invalid return, but it checks for (not) None.
    Different or custom types make it easier to connect certain flaw templates with
the proper initialization or input.

A higher level capability is to allow "qualified" types, e.g.
    <intput_type>int,primesOnly</input_type>
so flaws that need a particular "input" to be "hooked" to modules that produce that
particular output.

9 Nov 2022
Any module should be able to add imports or global declarations.  Specifically,
conditions or complexities may exercise certain libraries or packages or may need a
global variable declared.
    This allows file_template to be smaller.  The final code only includes say, math,
when it is needed.

Allow modules, other than complexities, to have <body></body> code. (Now you can put
ANYTHING in the XML, and anything unrecognized is just ignored.)

9 Nov 2022
VTSG doesn't have any notion of a fixed "support" file.  That is, a file written by
the developer that the test cases (may) need in order to execute.  This is like
testcasesupport files, for instance, io.c or std_testcase.h.
    This support file would have to be copied into any directory where test cases are
placed. 

7 Nov 2022
There should be some way to put several pieces of generated code in the same case, to
mimic Juliet's structure of having a bad version and one or more good versions in the
same file.

23 Nov 2022
Enhance the Juliet/Python tests with THREE variable scopes if you want to make sure
analyzers follow Python scope rules.
    Change localFive and globalFive to localConst and globalConst, and add an
enclosingConst.  These can be combinations of 5 or not 5.  Refer to scopeConst, e.g.
    def f():
        scopeConst = 6

	def g():
	    scopeConst = 5

	    if scopeConst == 5:
	        # this will always execute . . .
or perhaps
	scopeConst = globalConst

7 Nov 2022
Adding a // flaw line is only done for sink modules.  (In generator.py, around line
430; search for # add comment into code ...)  To be more general, perhaps VTSG should
be capable of adding a //flaw line in any module.

10 Nov 2022
Add a "new case hook". That is, every time a new case is written, VTSG will run
a script(?) you give as a "hook".  This takes advantage of modern
multiprocessors.  While VTSG is generating cases, the generated cases can be
checked or executed.

4 Nov 2022
Make the names of language modules consistent.  In particular, filter modules and
functions are often referred to as "filtering".
   Change language entries from {{ filtering_content }} to {{ filter_content }}?


Make sure the PHP and C# code runs, that is, that the generated programs are valid.
Fix any problems . . .

C#
  - check all str functions
  - Complexities :
      - if        : Testing
      - ternary   : None (possible?)
      - switch    : Testing
      - goto      : Testing
      - loop      : Testing
          - for       : Testing
          - while     : Testing
          - foreach   : Testing
      - function  : Testing (only trasversal/in/out)
      - classes   : Testing (only trasversal/in/out)
  # Not important
  - benchmark functions
  - use cython or JVM for optimization ?
  # Hard to do
  - add C# print debug to test if safe/unsafe or if it's executed
  - create bash script to compile and run all C# code
      -> compilation script done

Isolate code related to complexities.  Complexities relating to classes are
functional, however, the code needs to be isolated so it does not interfere with
other languages.  Python includes classes from other files using the “from {file}
import {class}” syntax, whereas other languages might not. This poses an issue when
generating other languages.  Example:
    cwe_78__I_hardcoded_string_input__F_no_filtering__S_ls__1x20b import Class_880
    This import for the file containing the class may not look anything like this in
    another language

Maybe add language-specific code in VTSG itself instead of trying to specify the
syntax (and composition rules) in, say, file_template.xml.  For example, C++ and C#
are far more similar in syntax than C# and Python.  This will help lessen the amount
of code that the generator runs specifically running only the functions it needs for
each language.


GENERATE MORE KINDS OF CASES

Extend VTSG & Python to handle (all?) Juliet-type cases
    (1) Now VTSG is structured to create injection cases. I don't know how well it
       could produce integer overflow, divide by zero, etc. type cases.
    (2) Juliet cases have lots of *type* variation: do the same thing, but with
       char, int, float, array, etc. Can we get VTSG to do that? Easily?
    This is probably a LOT of work since there are so many different kinds of test
    cases and complexities in Juliet.

Add swapped argument errors, see Vineeth Kashyap https://arxiv.org/abs/2009.09117

Add complexities from Kratkiewcz test cases

Generalize the structure of VTSG.  Now it looks for inputs, filters, and queries in
rigid combinations.  Maybe VTSG should read the template, then go hunting for each
kind of module mentioned.  Connections between them, via variables or call/return,
could be generalized.
    I don't know if this is even needed.  We first must work on handling Juliet and
other cases to discover any limitations VTSG has.


GENERATE CASES SMARTER

Don't "declare" local variables if not necessary, e.g., in Python.

Create s01, s02, s03, etc. subdirectories so there aren't hundreds of thousands of
cases in one directory.

Enhance VTSG to produce p% of cases.  That is, it would write 1 of every N
combinations, including complexities, that it comes up with.  This is an easy way to
approximate combinatorial tests.
    An alternative is to (pseudo)randomly decide which case to write.  That is, write
any case with probability p%.  This should write about p% of cases.  It must be
PSEDUOrandom so we can provide a seed and generate exactly the same cases in each
test run.
    The -n (number generated) option does something vaguely like this.  However, it
stops generation after N sink/filter/input/exec query combinations are generated.
Search for number_generated in generator.py.

Enhance VTSG to count and report (not print) cases.
    This is a prelude to combinatorial test generation, see next.

Incorporate combinatorial test generation
    Now VTSG generates all combinations, like Juliet. It may be useful to generate
    all n-way combinations.  This allows *far* more situations to be generated
    without making millions of cases.


OTHER? GENERAL?

Shorten the generated file name.  Or, add a --short-case-name option, to produce
Juliet-like names.
    A better alternative is to allow the user to specify generated file name in a
general format, like strftime, ISO/IEC 9899 (C90), or find -printf.  Here is a sample:
  %A is the full weekday name.
  %a is the abbreviated weekday name.
  %B is the full month name.
  %b is the abbreviated month name.
  %d is the day of the month as a decimal number (01-31).
  %H is the hour (24-hour clock) as a decimal number (00-23).
  %I is the hour (12-hour clock) as a decimal number (01-12).
  %M is the minute as a decimal number (00-59).
  %m is the month as a decimal number (01-12).

The built-in-test rules in the Makefile leave a lot of "junk" files and directories
in the current directory.  Put all the self-test stuff in another directory so the
top-level directory doesn't get cluttered.

Write manifest in our current SARIF-style.  There is sarif_writer.py, which is a
start from August 2020.  A newer implementation (Dec 2021) of sarif writer is in Paul's
Work/Ockham.

Update contact and license information in setup.py.  (Re)register in PyPI. Let
Bertrand know about this new GitHub repository, so he can "point" his to this one.

end of TODO
